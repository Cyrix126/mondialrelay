// Generated by https://github.com/lumeohq/xsd-parser-rs cli from view-source:https://www.mondialrelay.fr/media/51911/Mondial-Relay-Shipment-API-.Request.1.0.xsd

use serde::Deserialize;
use std::str::FromStr;
use xsd_macro_utils::{UtilsDefaultSerde, UtilsTupleIo};
use xsd_parser::generator::validator::Validate;
use yaserde::{YaDeserialize, YaSerialize};

pub type ShipmentCreationRequest = ShipmentCreationRequestType;

#[derive(Default, Clone, PartialEq, Debug, YaSerialize, YaDeserialize)]
#[yaserde(prefix = "tns", namespaces = {"tns" = "http://www.example.org/Request"})]
pub struct ShipmentCreationRequestType {
    #[yaserde(prefix = "tns", rename = "Context")]
    pub context: ContextType,

    #[yaserde(prefix = "tns", rename = "OutputOptions")]
    pub output_options: OutputOptionsType,

    #[yaserde(prefix = "tns", rename = "ShipmentsList")]
    pub shipments_list: ShipmentsListType,
}

impl Validate for ShipmentCreationRequestType {
    fn validate(&self) -> Result<(), String> {
        self.context.validate()?;
        self.output_options.validate()?;
        self.shipments_list.validate()?;
        Ok(())
    }
}

#[derive(Default, Clone, PartialEq, Debug, YaDeserialize, YaSerialize)]
#[yaserde(prefix = "tns", namespaces = {"tns" = "http://www.example.org/Request"})]
pub struct ContextType {
    // The user name of the client who calls the
    // service operation. Will be used for
    // authentication. The user name will be provided
    // by MondialRelay.
    #[yaserde(prefix = "tns", rename = "Login")]
    pub login: String,

    // The password of the client who calls the service
    // operation. Will be used for authentication. The
    // password will be provided by MondialRelay.
    #[yaserde(prefix = "tns", rename = "Password")]
    pub password: String,

    // The Customer Id of the client who calls the
    // service operation. Will be used for
    // authentication. The customerId will be provided
    // by MondialRelay.
    #[yaserde(prefix = "tns", rename = "CustomerId")]
    pub customer_id: context_type::CustomerIdType,

    // The culture that will be used to process the
    // request and produce the output expected format :
    // en-US
    #[yaserde(prefix = "tns", rename = "Culture")]
    pub culture: context_type::CultureType,

    // The reference of the API version.
    #[yaserde(prefix = "tns", rename = "VersionAPI")]
    pub version_api: context_type::VersionAPIType,
}

impl Validate for ContextType {}

pub mod context_type {

    use super::*;

    #[derive(Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde)]
    pub struct CustomerIdType(pub String);

    impl Validate for CustomerIdType {
        fn validate(&self) -> Result<(), String> {
            #[allow(clippy::len_zero)]
            if self.0.len() < 2 {
                return Err(format!("MinLength validation error. \nExpected: 0 length >= 2 \nActual: 0 length == {}", self.0.len()));
            }
            if self.0.len() > 8 {
                return Err(format!("MaxLength validation error. \nExpected: 0 length <= 8 \nActual: 0 length == {}", self.0.len()));
            }
            Ok(())
        }
    }

    #[derive(Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde)]
    pub struct CultureType(pub String);

    impl Validate for CultureType {
        fn validate(&self) -> Result<(), String> {
            if self.0.len() != 5 {
                return Err(format!(
                    "Length validation error. \nExpected: 0 length == 5 \nActual: 0 length == {}",
                    self.0.len()
                ));
            }
            Ok(())
        }
    }

    #[derive(Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde)]
    pub struct VersionAPIType(pub String);

    impl Validate for VersionAPIType {}
}

#[derive(Default, Clone, PartialEq, Debug, YaDeserialize, YaSerialize)]
#[yaserde(prefix = "tns", namespaces = {"tns" = "http://www.example.org/Request"})]
pub struct OutputOptionsType {
    // The printer model that will receive the ZPL
    // code. Bellow the model list of compatible
    // printers:
    #[yaserde(prefix = "tns", rename = "OutputFormat")]
    pub output_format: output_options_type::OutputFormatType,

    #[yaserde(prefix = "tns", rename = "OutputType")]
    pub output_type: output_options_type::OutputTypeType,
}

impl Validate for OutputOptionsType {}

pub mod output_options_type {
    use super::*;

    #[derive(Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde)]
    pub struct OutputFormatType(pub String);
    //The value depends on the outputType field:
    // For PDF file label, set the size format expected. Actual
    // supported formats are ‘A4’, ‘A5’, ‘10x15’.
    // For printing language label (ZPL, IPL), set the printer
    // model. Bellow the model list of compatible printers:
    // ‘Monarch9855’, ‘MiniMonarch9416XL’. For any new
    // model, please send us the printer model specifications

    impl Validate for OutputFormatType {}
    #[derive(Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde)]
    pub struct OutputTypeType(pub String);
    // The expected output format. Supported output format
    // list: ‘ZplCode’, ‘PdfUrl’, ‘IplCode’.
    impl Validate for OutputTypeType {}
}

#[derive(Default, Clone, PartialEq, Debug, YaDeserialize, YaSerialize)]
#[yaserde(prefix = "tns", namespaces = {"tns" = "http://example.org/Request"})]
pub struct ShipmentsListType {
    #[yaserde(prefix = "tns", rename = "Shipment")]
    pub shipment: Vec<ShipmentType>,
}

impl Validate for ShipmentsListType {}

#[derive(Default, Clone, PartialEq, Debug, YaSerialize, YaDeserialize)]
#[yaserde(prefix = "tns", namespaces = {"tns" = "http://example.org/Request"})]
pub struct ShipmentType {
    // Customer internal order reference of the shipped
    // content
    #[yaserde(prefix = "tns", rename = "OrderNo")]
    pub order_no: Option<shipment_type::OrderNoType>,

    #[yaserde(prefix = "tns", rename = "CustomerNo")]
    pub customer_no: Option<shipment_type::CustomerNoType>,

    // Number of parcels included in the shipment, this
    // number has to be coherent with the delivery and
    // the collection mode selected
    #[yaserde(prefix = "tns", rename = "ParcelCount")]
    pub parcel_count: shipment_type::ParcelCountType,

    // Value of the content
    #[yaserde(prefix = "tns", rename = "ShipmentValue")]
    pub shipment_value: Option<MonetaryAmountType>,
    // returns parcel
    #[yaserde(prefix = "tns", rename = "Options")]
    pub options: Option<OptionListType>,

    #[yaserde(prefix = "tns", rename = "DeliveryMode")]
    pub delivery_mode: ProductConfigurationType,

    #[yaserde(prefix = "tns", rename = "CollectionMode")]
    pub collection_mode: ProductConfigurationType,

    // List of parcels included in the shipment
    #[yaserde(prefix = "tns", rename = "Parcels")]
    pub parcels: ParcelListType,

    #[yaserde(prefix = "tns", rename = "DeliveryInstruction")]
    pub delivery_instruction: Option<shipment_type::DeliveryInstructionType>,

    // Informations about the sender of the parcel
    #[yaserde(prefix = "tns", rename = "Sender")]
    pub sender: SenderDetailsType,

    // Informations about the recipient of the parcel
    #[yaserde(prefix = "tns", rename = "Recipient")]
    pub recipient: RecipientDetailsType,
}

impl Validate for ShipmentType {}

pub mod shipment_type {
    use super::*;

    #[derive(Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde)]
    pub struct OrderNoType(pub String);

    impl Validate for OrderNoType {
        fn validate(&self) -> Result<(), String> {
            if self.0.len() > 15 {
                return Err(format!("MaxLength validation error. \nExpected: 0 length <= 15 \nActual: 0 length == {}", self.0.len()));
            }
            Ok(())
        }
    }

    #[derive(Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde)]
    pub struct CustomerNoType(pub String);

    impl Validate for CustomerNoType {
        fn validate(&self) -> Result<(), String> {
            if self.0.len() > 9 {
                return Err(format!("MaxLength validation error. \nExpected: 0 length <= 9 \nActual: 0 length == {}", self.0.len()));
            }
            Ok(())
        }
    }

    #[derive(Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde)]
    pub struct ParcelCountType(pub i32);

    impl Validate for ParcelCountType {
        fn validate(&self) -> Result<(), String> {
            if self.0 < "1".parse::<i32>().unwrap() {
                return Err(format!("MinInclusive validation error: invalid value of 0! \nExpected: 0 >= 1.\nActual: 0 == {}", self.0));
            }
            if self.0 > "99".parse::<i32>().unwrap() {
                return Err(format!("MaxInclusive validation error: invalid value of 0! \nExpected: 0 <= 99.\nActual: 0 == {}", self.0));
            }
            Ok(())
        }
    }

    #[derive(Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde)]
    pub struct DeliveryInstructionType(pub String);

    impl Validate for DeliveryInstructionType {}
}

#[derive(Default, Clone, PartialEq, Debug, YaSerialize, YaDeserialize)]
#[yaserde(prefix = "tns", namespaces = {"tns" = "http://example.org/Request"})]
pub struct MonetaryAmountType {
    // Currency of the amount
    #[yaserde(attribute = true, rename = "Currency")]
    pub currency: Option<String>,

    #[yaserde(attribute = true, rename = "Amount")]
    pub amount: Option<f64>,
}

impl Validate for MonetaryAmountType {}

#[derive(Default, Clone, PartialEq, Debug, YaSerialize, YaDeserialize)]
#[yaserde(prefix = "tns", namespaces = {"tns" = "http://example.org/Request"})]
pub struct OptionListType {
    #[yaserde(prefix = "tns", rename = "Option")]
    pub option: Vec<KeyValueType>,
}

impl Validate for OptionListType {}

#[derive(Default, Clone, PartialEq, Debug, YaSerialize, YaDeserialize)]
#[yaserde(prefix = "tns", namespaces = {"tns" = "http://example.org/Request"})]
pub struct KeyValueType {
    #[yaserde(attribute = true, rename = "Key")]
    pub key: Option<String>,

    #[yaserde(attribute = true, rename = "Value")]
    pub value: Option<String>,
}

impl Validate for KeyValueType {}

#[derive(Default, Clone, PartialEq, Debug, YaSerialize, YaDeserialize)]
#[yaserde(prefix = "tns", namespaces = {"tns" = "http://example.org/Request"})]
pub struct ProductConfigurationType {
    // Collection
    // CCC : Merchant collection
    // REL : Point Relais® collection

    // Delivery
    // The product code for the operation
    // • HOM : Home delivery
    // • 24R : Point Relais® delivery
    // • 24L : Point Relais® XL delivery
    // • XOH: D+1 Delivery for this delivery mode, a specific action is mandatory by EDI in addition to
    // the creation of the shipment and label by this API. So, please refer to the EDI specification file
    // and the file “leaving warehouse”.
    #[yaserde(attribute = true, rename = "Mode")]
    pub mode: String,

    // Location code where the presatation will be done (ie : the parcel shop ID
    // (FR00001) for parcel shop delivery )
    // doc show FR-00001 but schema show FR00001
    // Auto will determine from address ?
    #[yaserde(attribute = true, rename = "Location")]
    pub location: Option<String>,
}

impl Validate for ProductConfigurationType {}

#[derive(Default, Clone, PartialEq, Debug, YaSerialize, YaDeserialize)]
#[yaserde(prefix = "tns", namespaces = {"tns" = "http://example.org/Request"})]
pub struct ParcelListType {
    // each parcel of the shipment will be described with an element
    #[yaserde(prefix = "tns", rename = "Parcel")]
    pub parcel: Vec<ParcelType>,
}

impl Validate for ParcelListType {}

#[derive(Default, Clone, PartialEq, Debug, YaSerialize, YaDeserialize)]
#[yaserde(prefix = "tns", namespaces = {"tns" = "http://example.org/Request"})]
pub struct ParcelType {
    // A brief description of the parcel content
    #[yaserde(prefix = "tns", rename = "Content")]
    pub content: Option<parcel_type::ContentType>,

    // The length of the parcel (in cm) , unit has to be specified in the unit
    // attribute = true
    #[yaserde(prefix = "tns", rename = "Length")]
    pub length: MeasureAmountType,

    // The width of the parcel (in cm) , unit has to be specified in the unit
    // attribute = true
    #[yaserde(prefix = "tns", rename = "Width")]
    pub width: MeasureAmountType,

    // The depth of the parcel (in cm) , unit has to be specified in the unit
    // attribute = true
    #[yaserde(prefix = "tns", rename = "Depth")]
    pub depth: MeasureAmountType,

    // The weight of the parcel (in gram) , unit has to be specified in the unit
    // attribute = true
    #[yaserde(prefix = "tns", rename = "Weight")]
    pub weight: MeasureAmountType,
}

impl Validate for ParcelType {}

pub mod parcel_type {
    use super::*;

    #[derive(Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde)]
    pub struct ContentType(pub String);

    impl Validate for ContentType {
        fn validate(&self) -> Result<(), String> {
            if self.0.len() > 40 {
                return Err(format!("MaxLength validation error. \nExpected: 0 length <= 40 \nActual: 0 length == {}", self.0.len()));
            }
            Ok(())
        }
    }
}

#[derive(Default, Clone, PartialEq, Debug, YaSerialize, YaDeserialize)]
#[yaserde(prefix = "tns", namespaces = {"tns" = "http://example.org/Request"})]
pub struct MeasureAmountType {
    #[yaserde(attribute = true, rename = "Value")]
    pub value: f64,

    #[yaserde(attribute = true, rename = "Unit")]
    pub unit: String,
}

impl Validate for MeasureAmountType {}

#[derive(Default, Clone, PartialEq, Debug, YaSerialize, YaDeserialize)]
#[yaserde(prefix = "tns", namespaces = {"tns" = "http://example.org/Request"})]
pub struct SenderDetailsType {
    #[yaserde(prefix = "tns", rename = "Address")]
    pub address: AddressType,
}

impl Validate for SenderDetailsType {}

#[derive(Default, Clone, PartialEq, Debug, YaSerialize, YaDeserialize)]
#[yaserde(prefix = "tns", namespaces = {"tns" = "http://example.org/Request"})]
pub struct RecipientDetailsType {
    #[yaserde(prefix = "tns", rename = "Address")]
    pub address: AddressType,
}

impl Validate for RecipientDetailsType {}

#[derive(Default, Clone, PartialEq, Debug, YaSerialize, YaDeserialize, Deserialize)]
#[yaserde(prefix = "tns", namespaces = {"tns" = "http://example.org/Request"})]
pub struct AddressType {
    // If the address is a person, this field is for the person title (Mr, Ms,
    // Miss, ...)
    #[yaserde(prefix = "tns", rename = "Title")]
    pub title: Option<address_type::TitleType>,

    // If the address is a person
    #[yaserde(prefix = "tns", rename = "Firstname")]
    pub firstname: Option<address_type::FirstnameType>,

    // If the address is a person,
    #[yaserde(prefix = "tns", rename = "Lastname")]
    pub lastname: Option<address_type::LastnameType>,

    #[yaserde(prefix = "tns", rename = "Streetname")]
    pub streetname: String,

    #[yaserde(prefix = "tns", rename = "HouseNo")]
    pub house_no: Option<address_type::HouseNoType>,

    // The two letter country code of the addressee (e. g. DE, GB). For a
    // complete list of country code, refer to the standard ISO 3166-1-alpha-2
    #[yaserde(prefix = "tns", rename = "CountryCode")]
    pub country_code: address_type::CountryCodeType,

    #[yaserde(prefix = "tns", rename = "PostCode")]
    pub post_code: address_type::PostCodeType,

    #[yaserde(prefix = "tns", rename = "City")]
    pub city: address_type::CityType,

    #[yaserde(prefix = "tns", rename = "AddressAdd1")]
    pub address_add_1: Option<address_type::AddressAdd1Type>,

    // Additional address information (e.g. Building, Floor).
    #[yaserde(prefix = "tns", rename = "AddressAdd2")]
    pub address_add_2: Option<address_type::AddressAdd2Type>,

    // Additional address information (e.g. locality
    // name).
    #[yaserde(prefix = "tns", rename = "AddressAdd3")]
    pub address_add_3: Option<address_type::AddressAdd3Type>,

    // The phone number of the addressee. Please
    // specify the area code (e.g. +33 for FRANCE).
    #[yaserde(prefix = "tns", rename = "PhoneNo")]
    pub phone_no: address_type::PhoneNoType,

    // The mobile phone number of the addressee. Please
    // specify the area code (e.g. +33 for FRANCE).
    #[yaserde(prefix = "tns", rename = "MobileNo")]
    pub mobile_no: Option<address_type::MobileNoType>,

    // The email address of the addressee.
    // Format : xxxxxx@xxx.xx
    #[yaserde(prefix = "tns", rename = "Email")]
    pub email: Option<address_type::EmailType>,
}

impl Validate for AddressType {}

pub mod address_type {
    use super::*;

    #[derive(Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde, Deserialize)]
    pub struct TitleType(pub String);

    impl Validate for TitleType {
        fn validate(&self) -> Result<(), String> {
            if self.0.len() > 30 {
                return Err(format!("MaxLength validation error. \nExpected: 0 length <= 30 \nActual: 0 length == {}", self.0.len()));
            }
            Ok(())
        }
    }

    #[derive(Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde, Deserialize)]
    pub struct FirstnameType(pub String);

    impl Validate for FirstnameType {
        fn validate(&self) -> Result<(), String> {
            if self.0.len() > 30 {
                return Err(format!("MaxLength validation error. \nExpected: 0 length <= 30 \nActual: 0 length == {}", self.0.len()));
            }
            Ok(())
        }
    }

    #[derive(Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde, Deserialize)]
    pub struct LastnameType(pub String);

    impl Validate for LastnameType {
        fn validate(&self) -> Result<(), String> {
            if self.0.len() > 30 {
                return Err(format!("MaxLength validation error. \nExpected: 0 length <= 30 \nActual: 0 length == {}", self.0.len()));
            }
            Ok(())
        }
    }

    #[derive(Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde, Deserialize)]
    pub struct HouseNoType(pub String);

    impl Validate for HouseNoType {
        fn validate(&self) -> Result<(), String> {
            if self.0.len() > 10 {
                return Err(format!("MaxLength validation error. \nExpected: 0 length <= 10 \nActual: 0 length == {}", self.0.len()));
            }
            Ok(())
        }
    }

    #[derive(Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde, Deserialize)]
    pub struct CountryCodeType(pub String);

    impl Validate for CountryCodeType {
        fn validate(&self) -> Result<(), String> {
            if self.0.len() != 2 {
                return Err(format!(
                    "Length validation error. \nExpected: 0 length == 2 \nActual: 0 length == {}",
                    self.0.len()
                ));
            }
            Ok(())
        }
    }

    #[derive(Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde, Deserialize)]
    pub struct PostCodeType(pub String);

    impl Validate for PostCodeType {
        fn validate(&self) -> Result<(), String> {
            if self.0.len() > 10 {
                return Err(format!("MaxLength validation error. \nExpected: 0 length <= 10 \nActual: 0 length == {}", self.0.len()));
            }
            Ok(())
        }
    }

    #[derive(Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde, Deserialize)]
    pub struct CityType(pub String);

    impl Validate for CityType {
        fn validate(&self) -> Result<(), String> {
            if self.0.len() > 30 {
                return Err(format!("MaxLength validation error. \nExpected: 0 length <= 30 \nActual: 0 length == {}", self.0.len()));
            }
            Ok(())
        }
    }

    #[derive(Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde, Deserialize)]
    pub struct AddressAdd1Type(pub String);

    impl Validate for AddressAdd1Type {
        fn validate(&self) -> Result<(), String> {
            if self.0.len() > 30 {
                return Err(format!("MaxLength validation error. \nExpected: 0 length <= 30 \nActual: 0 length == {}", self.0.len()));
            }
            Ok(())
        }
    }

    #[derive(Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde, Deserialize)]
    pub struct AddressAdd2Type(pub String);

    impl Validate for AddressAdd2Type {
        fn validate(&self) -> Result<(), String> {
            if self.0.len() > 30 {
                return Err(format!("MaxLength validation error. \nExpected: 0 length <= 30 \nActual: 0 length == {}", self.0.len()));
            }
            Ok(())
        }
    }

    #[derive(Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde, Deserialize)]
    pub struct AddressAdd3Type(pub String);

    impl Validate for AddressAdd3Type {
        fn validate(&self) -> Result<(), String> {
            if self.0.len() > 30 {
                return Err(format!("MaxLength validation error. \nExpected: 0 length <= 30 \nActual: 0 length == {}", self.0.len()));
            }
            Ok(())
        }
    }

    #[derive(Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde, Deserialize)]
    pub struct PhoneNoType(pub String);

    impl Validate for PhoneNoType {
        fn validate(&self) -> Result<(), String> {
            if self.0.len() > 20 {
                return Err(format!("MaxLength validation error. \nExpected: 0 length <= 20 \nActual: 0 length == {}", self.0.len()));
            }
            Ok(())
        }
    }

    #[derive(Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde, Deserialize)]
    pub struct MobileNoType(pub String);

    impl Validate for MobileNoType {
        fn validate(&self) -> Result<(), String> {
            if self.0.len() > 20 {
                return Err(format!("MaxLength validation error. \nExpected: 0 length <= 20 \nActual: 0 length == {}", self.0.len()));
            }
            Ok(())
        }
    }

    #[derive(Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde, Deserialize)]
    pub struct EmailType(pub String);

    impl Validate for EmailType {
        fn validate(&self) -> Result<(), String> {
            if self.0.len() > 70 {
                return Err(format!("MaxLength validation error. \nExpected: 0 length <= 70 \nActual: 0 length == {}", self.0.len()));
            }
            Ok(())
        }
    }
}
