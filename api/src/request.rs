// Generated by https://github.com/lumeohq/xsd-parser-rs cli from view-source:https://www.mondialrelay.fr/media/51911/Mondial-Relay-Shipment-API-.Request.1.0.xsd

use serde::{Deserialize, Serialize};
use std::str::FromStr;
use xsd_macro_utils::{UtilsDefaultSerde, UtilsTupleIo};
use xsd_parser::generator::validator::Validate;
use yaserde::{YaDeserialize, YaSerialize};

use crate::{config::Config, error::AppError, handler::NewShipment};

#[derive(Default, Clone, PartialEq, Debug, YaSerialize, YaDeserialize)]
#[yaserde(namespaces = {"xsi" = "http://www.w3.org/2001/XMLSchema-instance", "xsd" = "http://www.w3.org/2001/XMLSchema", "" = "http://www.example.org/Request"})]
pub struct ShipmentCreationRequest {
    #[yaserde(rename = "Context")]
    pub context: Context,

    #[yaserde(rename = "OutputOptions")]
    pub output_options: OutputOptions,

    #[yaserde(rename = "ShipmentsList")]
    pub shipments_list: ShipmentsList,
}

impl Validate for ShipmentCreationRequest {
    fn validate(&self) -> Result<(), String> {
        self.context.validate()?;
        self.output_options.validate()?;
        self.shipments_list.validate()?;
        Ok(())
    }
}

impl ShipmentCreationRequest {
    pub fn new(config: Config, data: NewShipment) -> Result<Self, AppError> {
        Ok(ShipmentCreationRequest {
            context: config
                .context_api_mondialrelay()
                .map_err(|_| AppError::Conf)?,
            output_options: OutputOptions {
                output_format: output_options_type::OutputFormat(config.format.clone()),
                output_type: output_options_type::OutputType("PdfUrl".to_string()),
            },
            shipments_list: ShipmentsList {
                shipment: vec![Shipment {
                    // MondialRelay doesn't need to know our customer id nor order id
                    order_no: None,
                    customer_no: None,
                    parcel_count: shipment_type::ParcelCount(1),
                    shipment_value: None,
                    options: None,
                    delivery_mode: ProductConfiguration {
                        mode: data.delivery_mode,
                        location: data.delivery_location,
                    },
                    collection_mode: ProductConfiguration {
                        mode: "CCC".to_string(),
                        location: None,
                    },
                    parcels: ParcelList {
                        parcel: vec![Parcel {
                            content: None,
                            length: MeasureAmount {
                                value: data.length as f64,
                                unit: "cm".to_string(),
                            },
                            width: MeasureAmount {
                                value: data.width as f64,
                                unit: "cm".to_string(),
                            },
                            depth: MeasureAmount {
                                value: data.depth as f64,
                                unit: "cm".to_string(),
                            },
                            weight: MeasureAmount {
                                value: data.weight as f64,
                                unit: "gr".to_string(),
                            },
                        }],
                    },
                    delivery_instruction: data
                        .delivery_instructions
                        .map(shipment_type::DeliveryInstruction),
                    sender: SenderDetails {
                        address: config.sender_address(),
                    },
                    recipient: crate::request::RecipientDetails {
                        address: data.recipient_details,
                    },
                }],
            },
        })
    }
}

#[derive(Default, Clone, PartialEq, Debug, YaDeserialize, YaSerialize)]
pub struct Context {
    // The user name of the client who calls the
    // service operation. Will be used for
    // authentication. The user name will be provided
    // by MondialRelay.
    #[yaserde(rename = "Login")]
    pub login: String,

    // The password of the client who calls the service
    // operation. Will be used for authentication. The
    // password will be provided by MondialRelay.
    #[yaserde(rename = "Password")]
    pub password: String,

    // The Customer Id of the client who calls the
    // service operation. Will be used for
    // authentication. The customerId will be provided
    // by MondialRelay.
    #[yaserde(rename = "CustomerId")]
    pub customer_id: context_type::CustomerId,

    // The culture that will be used to process the
    // request and produce the output expected format :
    // en-US
    #[yaserde(rename = "Culture")]
    pub culture: context_type::Culture,

    // The reference of the API version.
    #[yaserde(rename = "VersionAPI")]
    pub version_api: context_type::VersionAPI,
}

impl Validate for Context {}

pub mod context_type {

    use super::*;

    #[derive(Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde)]
    pub struct CustomerId(pub String);

    impl Validate for CustomerId {
        fn validate(&self) -> Result<(), String> {
            #[allow(clippy::len_zero)]
            if self.0.len() < 2 {
                return Err(format!("MinLength validation error. \nExpected: 0 length >= 2 \nActual: 0 length == {}", self.0.len()));
            }
            if self.0.len() > 8 {
                return Err(format!("MaxLength validation error. \nExpected: 0 length <= 8 \nActual: 0 length == {}", self.0.len()));
            }
            Ok(())
        }
    }

    #[derive(Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde)]
    pub struct Culture(pub String);

    impl Validate for Culture {
        fn validate(&self) -> Result<(), String> {
            if self.0.len() != 5 {
                return Err(format!(
                    "Length validation error. \nExpected: 0 length == 5 \nActual: 0 length == {}",
                    self.0.len()
                ));
            }
            Ok(())
        }
    }

    #[derive(Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde)]
    pub struct VersionAPI(pub String);

    impl Validate for VersionAPI {}
}

#[derive(Default, Clone, PartialEq, Debug, YaDeserialize, YaSerialize)]
pub struct OutputOptions {
    // The printer model that will receive the ZPL
    // code. Bellow the model list of compatible
    // printers:
    #[yaserde(rename = "OutputFormat")]
    pub output_format: output_options_type::OutputFormat,

    #[yaserde(rename = "OutputType")]
    pub output_type: output_options_type::OutputType,
}

impl Validate for OutputOptions {}

pub mod output_options_type {
    use super::*;

    #[derive(Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde)]
    pub struct OutputFormat(pub String);
    //The value depends on the output field:
    // For PDF file label, set the size format expected. Actual
    // supported formats are ‘A4’, ‘A5’, ‘10x15’.
    // For printing language label (ZPL, IPL), set the printer
    // model. Bellow the model list of compatible printers:
    // ‘Monarch9855’, ‘MiniMonarch9416XL’. For any new
    // model, please send us the printer model specifications

    impl Validate for OutputFormat {}
    #[derive(Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde)]
    pub struct OutputType(pub String);
    // The expected output format. Supported output format
    // list: ‘ZplCode’, ‘PdfUrl’, ‘IplCode’.
    impl Validate for OutputType {}
}

#[derive(Default, Clone, PartialEq, Debug, YaDeserialize, YaSerialize)]
pub struct ShipmentsList {
    #[yaserde(rename = "Shipment")]
    pub shipment: Vec<Shipment>,
}

impl Validate for ShipmentsList {}

#[derive(Default, Clone, PartialEq, Debug, YaSerialize, YaDeserialize)]
pub struct Shipment {
    // Customer internal order reference of the shipped
    // content
    #[yaserde(rename = "OrderNo")]
    pub order_no: Option<shipment_type::OrderNo>,

    #[yaserde(rename = "CustomerNo")]
    pub customer_no: Option<shipment_type::CustomerNo>,

    // Number of parcels included in the shipment, this
    // number has to be coherent with the delivery and
    // the collection mode selected
    #[yaserde(rename = "ParcelCount")]
    pub parcel_count: shipment_type::ParcelCount,

    // Value of the content
    #[yaserde(rename = "ShipmentValue")]
    pub shipment_value: Option<MonetaryAmount>,
    // returns parcel
    #[yaserde(rename = "Options")]
    pub options: Option<OptionList>,

    #[yaserde(rename = "DeliveryMode")]
    pub delivery_mode: ProductConfiguration,

    #[yaserde(rename = "CollectionMode")]
    pub collection_mode: ProductConfiguration,

    // List of parcels included in the shipment
    #[yaserde(rename = "Parcels")]
    pub parcels: ParcelList,

    #[yaserde(rename = "DeliveryInstruction")]
    pub delivery_instruction: Option<shipment_type::DeliveryInstruction>,

    // Informations about the sender of the parcel
    #[yaserde(rename = "Sender")]
    pub sender: SenderDetails,

    // Informations about the recipient of the parcel
    #[yaserde(rename = "Recipient")]
    pub recipient: RecipientDetails,
}

impl Validate for Shipment {}

pub mod shipment_type {
    use super::*;

    #[derive(Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde)]
    pub struct OrderNo(pub String);

    impl Validate for OrderNo {
        fn validate(&self) -> Result<(), String> {
            if self.0.len() > 15 {
                return Err(format!("MaxLength validation error. \nExpected: 0 length <= 15 \nActual: 0 length == {}", self.0.len()));
            }
            Ok(())
        }
    }

    #[derive(Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde)]
    pub struct CustomerNo(pub String);

    impl Validate for CustomerNo {
        fn validate(&self) -> Result<(), String> {
            if self.0.len() > 9 {
                return Err(format!("MaxLength validation error. \nExpected: 0 length <= 9 \nActual: 0 length == {}", self.0.len()));
            }
            Ok(())
        }
    }

    #[derive(Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde)]
    pub struct ParcelCount(pub i32);

    impl Validate for ParcelCount {
        fn validate(&self) -> Result<(), String> {
            if self.0 < "1".parse::<i32>().unwrap() {
                return Err(format!("MinInclusive validation error: invalid value of 0! \nExpected: 0 >= 1.\nActual: 0 == {}", self.0));
            }
            if self.0 > "99".parse::<i32>().unwrap() {
                return Err(format!("MaxInclusive validation error: invalid value of 0! \nExpected: 0 <= 99.\nActual: 0 == {}", self.0));
            }
            Ok(())
        }
    }

    #[derive(Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde)]
    pub struct DeliveryInstruction(pub String);

    impl Validate for DeliveryInstruction {}
}

#[derive(Default, Clone, PartialEq, Debug, YaSerialize, YaDeserialize)]
pub struct MonetaryAmount {
    // Currency of the amount
    #[yaserde(attribute = true, rename = "Currency")]
    pub currency: Option<String>,

    #[yaserde(attribute = true, rename = "Amount")]
    pub amount: Option<f64>,
}

impl Validate for MonetaryAmount {}

#[derive(Default, Clone, PartialEq, Debug, YaSerialize, YaDeserialize)]
pub struct OptionList {
    #[yaserde(rename = "Option")]
    pub option: Vec<KeyValue>,
}

impl Validate for OptionList {}

#[derive(Default, Clone, PartialEq, Debug, YaSerialize, YaDeserialize)]
pub struct KeyValue {
    #[yaserde(attribute = true, rename = "Key")]
    pub key: Option<String>,

    #[yaserde(attribute = true, rename = "Value")]
    pub value: Option<String>,
}

impl Validate for KeyValue {}

#[derive(Default, Clone, PartialEq, Debug, YaSerialize, YaDeserialize)]
pub struct ProductConfiguration {
    // Collection
    // CCC : Merchant collection
    // REL : Point Relais® collection

    // Delivery
    // The product code for the operation
    // • HOM : Home delivery
    // • 24R : Point Relais® delivery
    // • 24L : Point Relais® XL delivery
    // • XOH: D+1 Delivery for this delivery mode, a specific action is mandatory by EDI in addition to
    // the creation of the shipment and label by this API. So, please refer to the EDI specification file
    // and the file “leaving warehouse”.
    #[yaserde(attribute = true, rename = "Mode")]
    pub mode: String,

    // Location code where the presatation will be done (ie : the parcel shop ID
    // (FR00001) for parcel shop delivery )
    // doc show FR-00001 but schema show FR00001
    // Auto will determine from address ?
    #[yaserde(attribute = true, rename = "Location")]
    pub location: Option<String>,
}

impl Validate for ProductConfiguration {}

#[derive(Default, Clone, PartialEq, Debug, YaSerialize, YaDeserialize)]
pub struct ParcelList {
    // each parcel of the shipment will be described with an element
    #[yaserde(rename = "Parcel")]
    pub parcel: Vec<Parcel>,
}

impl Validate for ParcelList {}

#[derive(Default, Clone, PartialEq, Debug, YaSerialize, YaDeserialize)]
pub struct Parcel {
    // A brief description of the parcel content
    #[yaserde(rename = "Content")]
    pub content: Option<parcel_type::Content>,

    // The length of the parcel (in cm) , unit has to be specified in the unit
    // attribute = true
    #[yaserde(rename = "Length")]
    pub length: MeasureAmount,

    // The width of the parcel (in cm) , unit has to be specified in the unit
    // attribute = true
    #[yaserde(rename = "Width")]
    pub width: MeasureAmount,

    // The depth of the parcel (in cm) , unit has to be specified in the unit
    // attribute = true
    #[yaserde(rename = "Depth")]
    pub depth: MeasureAmount,

    // The weight of the parcel (in gram) , unit has to be specified in the unit
    // attribute = true
    #[yaserde(rename = "Weight")]
    pub weight: MeasureAmount,
}

impl Validate for Parcel {}

pub mod parcel_type {
    use super::*;

    #[derive(Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde)]
    pub struct Content(pub String);

    impl Validate for Content {
        fn validate(&self) -> Result<(), String> {
            if self.0.len() > 40 {
                return Err(format!("MaxLength validation error. \nExpected: 0 length <= 40 \nActual: 0 length == {}", self.0.len()));
            }
            Ok(())
        }
    }
}

#[derive(Default, Clone, PartialEq, Debug, YaSerialize, YaDeserialize)]
pub struct MeasureAmount {
    #[yaserde(attribute = true, rename = "Value")]
    pub value: f64,

    #[yaserde(attribute = true, rename = "Unit")]
    pub unit: String,
}

impl Validate for MeasureAmount {}

#[derive(Default, Clone, PartialEq, Debug, YaSerialize, YaDeserialize)]
pub struct SenderDetails {
    #[yaserde(rename = "Address")]
    pub address: Address,
}

impl Validate for SenderDetails {}

#[derive(Default, Clone, PartialEq, Debug, YaSerialize, YaDeserialize)]
pub struct RecipientDetails {
    #[yaserde(rename = "Address")]
    pub address: Address,
}

impl Validate for RecipientDetails {}

#[derive(Default, Clone, PartialEq, Debug, YaSerialize, YaDeserialize, Deserialize, Serialize)]
pub struct Address {
    // If the address is a person, this field is for the person title (Mr, Ms,
    // Miss, ...)
    #[yaserde(rename = "Title")]
    pub title: Option<address_type::Title>,

    // If the address is a person
    #[yaserde(rename = "Firstname")]
    pub firstname: Option<address_type::Firstname>,

    // If the address is a person,
    #[yaserde(rename = "Lastname")]
    pub lastname: Option<address_type::Lastname>,

    #[yaserde(rename = "Streetname")]
    pub streetname: String,

    #[yaserde(rename = "HouseNo")]
    pub house_no: Option<address_type::HouseNo>,

    // The two letter country code of the addressee (e. g. DE, GB). For a
    // complete list of country code, refer to the standard ISO 3166-1-alpha-2
    #[yaserde(rename = "CountryCode")]
    pub country_code: address_type::CountryCode,

    #[yaserde(rename = "PostCode")]
    pub post_code: address_type::PostCode,

    #[yaserde(rename = "City")]
    pub city: address_type::City,

    #[yaserde(rename = "AddressAdd1")]
    pub address_add_1: Option<address_type::AddressAdd1>,

    // Additional address information (e.g. Building, Floor).
    #[yaserde(rename = "AddressAdd2")]
    pub address_add_2: Option<address_type::AddressAdd2>,

    // Additional address information (e.g. locality
    // name).
    #[yaserde(rename = "AddressAdd3")]
    pub address_add_3: Option<address_type::AddressAdd3>,

    // The phone number of the addressee. Please
    // specify the area code (e.g. +33 for FRANCE).
    #[yaserde(rename = "PhoneNo")]
    pub phone_no: address_type::PhoneNo,

    // The mobile phone number of the addressee. Please
    // specify the area code (e.g. +33 for FRANCE).
    #[yaserde(rename = "MobileNo")]
    pub mobile_no: Option<address_type::MobileNo>,

    // The email address of the addressee.
    // Format : xxxxxx@xxx.xx
    #[yaserde(rename = "Email")]
    pub email: Option<address_type::Email>,
}

impl Validate for Address {}

pub mod address_type {
    use super::*;

    #[derive(
        Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde, Deserialize, Serialize,
    )]
    pub struct Title(pub String);

    impl Validate for Title {
        fn validate(&self) -> Result<(), String> {
            if self.0.len() > 30 {
                return Err(format!("MaxLength validation error. \nExpected: 0 length <= 30 \nActual: 0 length == {}", self.0.len()));
            }
            Ok(())
        }
    }

    #[derive(
        Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde, Deserialize, Serialize,
    )]
    pub struct Firstname(pub String);

    impl Validate for Firstname {
        fn validate(&self) -> Result<(), String> {
            if self.0.len() > 30 {
                return Err(format!("MaxLength validation error. \nExpected: 0 length <= 30 \nActual: 0 length == {}", self.0.len()));
            }
            Ok(())
        }
    }

    #[derive(
        Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde, Deserialize, Serialize,
    )]
    pub struct Lastname(pub String);

    impl Validate for Lastname {
        fn validate(&self) -> Result<(), String> {
            if self.0.len() > 30 {
                return Err(format!("MaxLength validation error. \nExpected: 0 length <= 30 \nActual: 0 length == {}", self.0.len()));
            }
            Ok(())
        }
    }

    #[derive(
        Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde, Deserialize, Serialize,
    )]
    pub struct HouseNo(pub String);

    impl Validate for HouseNo {
        fn validate(&self) -> Result<(), String> {
            if self.0.len() > 10 {
                return Err(format!("MaxLength validation error. \nExpected: 0 length <= 10 \nActual: 0 length == {}", self.0.len()));
            }
            // check every street number possible for street ?
            Ok(())
        }
    }

    #[derive(
        Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde, Deserialize, Serialize,
    )]
    pub struct CountryCode(pub String);

    impl Validate for CountryCode {
        fn validate(&self) -> Result<(), String> {
            if self.0.len() != 2 {
                return Err(format!(
                    "Length validation error. \nExpected: 0 length == 2 \nActual: 0 length == {}",
                    self.0.len()
                ));
            }
            // check every country code ?
            Ok(())
        }
    }

    #[derive(
        Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde, Deserialize, Serialize,
    )]
    pub struct PostCode(pub String);

    impl Validate for PostCode {
        fn validate(&self) -> Result<(), String> {
            if self.0.len() > 10 {
                return Err(format!("MaxLength validation error. \nExpected: 0 length <= 10 \nActual: 0 length == {}", self.0.len()));
            }
            // check every postal code ?
            Ok(())
        }
    }

    #[derive(
        Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde, Deserialize, Serialize,
    )]
    pub struct City(pub String);

    impl Validate for City {
        fn validate(&self) -> Result<(), String> {
            if self.0.len() > 30 {
                return Err(format!("MaxLength validation error. \nExpected: 0 length <= 30 \nActual: 0 length == {}", self.0.len()));
            }
            // check that city correspond to postal code ?
            Ok(())
        }
    }

    #[derive(
        Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde, Deserialize, Serialize,
    )]
    pub struct AddressAdd1(pub String);

    impl Validate for AddressAdd1 {
        fn validate(&self) -> Result<(), String> {
            if self.0.len() > 30 {
                return Err(format!("MaxLength validation error. \nExpected: 0 length <= 30 \nActual: 0 length == {}", self.0.len()));
            }
            Ok(())
        }
    }

    #[derive(
        Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde, Deserialize, Serialize,
    )]
    pub struct AddressAdd2(pub String);

    impl Validate for AddressAdd2 {
        fn validate(&self) -> Result<(), String> {
            if self.0.len() > 30 {
                return Err(format!("MaxLength validation error. \nExpected: 0 length <= 30 \nActual: 0 length == {}", self.0.len()));
            }
            Ok(())
        }
    }

    #[derive(
        Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde, Deserialize, Serialize,
    )]
    pub struct AddressAdd3(pub String);

    impl Validate for AddressAdd3 {
        fn validate(&self) -> Result<(), String> {
            if self.0.len() > 30 {
                return Err(format!("MaxLength validation error. \nExpected: 0 length <= 30 \nActual: 0 length == {}", self.0.len()));
            }
            Ok(())
        }
    }

    #[derive(
        Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde, Deserialize, Serialize,
    )]
    pub struct PhoneNo(pub String);

    impl Validate for PhoneNo {
        fn validate(&self) -> Result<(), String> {
            if self.0.len() > 20 {
                return Err(format!("MaxLength validation error. \nExpected: 0 length <= 20 \nActual: 0 length == {}", self.0.len()));
            }
            Ok(())
        }
    }

    #[derive(
        Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde, Deserialize, Serialize,
    )]
    pub struct MobileNo(pub String);

    impl Validate for MobileNo {
        fn validate(&self) -> Result<(), String> {
            if self.0.len() > 20 {
                return Err(format!("MaxLength validation error. \nExpected: 0 length <= 20 \nActual: 0 length == {}", self.0.len()));
            }
            Ok(())
        }
    }

    #[derive(
        Default, Clone, PartialEq, Debug, UtilsTupleIo, UtilsDefaultSerde, Deserialize, Serialize,
    )]
    pub struct Email(pub String);

    impl Validate for Email {
        fn validate(&self) -> Result<(), String> {
            if self.0.len() > 70 {
                return Err(format!("MaxLength validation error. \nExpected: 0 length <= 70 \nActual: 0 length == {}", self.0.len()));
            }
            Ok(())
        }
    }
}
